## tar

```bash
wget 10.10.6.181/ansible-defaults.tar.gz
mkdir ooo
tar -zxvf ansible-defaults.tar.gz -C ooo


```





## ln软链接

```sh

file1=calicoctl
ln -sf /etc/ansible/bin/${file1} /usr/bin/${file1} 

```

> -b 删除，覆盖以前建立的链接
> -d 允许超级用户制作目录的硬链接
> -f 强制执行
> -i 交互模式，文件存在则提示用户是否覆盖
> -n 把符号链接视为一般目录
> -s 软链接(符号链接)
> -v 显示详细的处理过程
>
>
> 选择参数:
>
> -S “-S<字尾备份字符串> ”或 “--suffix=<字尾备份字符串>”
>
> -V “-V<备份方式>”或“--version-control=<备份方式>”
>
> --help 显示帮助信息
>
> --version 显示版本信息



## curl

```bash
curl -fL --retry 3 ${umirror}/${urep}/archive/${ufile} -o ~/uon/${ufile} --create-dirs
```

## wget

```bash
wget -r -np -nH 10.10.6.19/kernel-up/ -P ~/uon/
```

> **-r** : 遍历所有子目录
>
> **-np** : 不到上一层子目录去
>
> **-nH** : 不要将文件保存到主机名文件夹
>
> **-R index.html** : 不下载 index.html 文件
>
>  **-P** 指定目录
>
> **-c** 断点续传

## $

```bash
$?	#返回值 0正常 其他报错
$1	#传入参数1
$2	#传入参数2
${10}	#传入参数10
```

## echo

| RED="31m"     |
| ------------- |
| GREEN="32m"   |
| YELLOW="33m"  |
| BLUE="36m"    |
| FUCHSIA="35m" |



```bash
echo -e "\e[1;31mextract failed\e[0m"
echo -e "\e[1;。。m。。。。。。。\e[0m"
# 31 红色   32 绿色
```

## cp

```bash
cp -rf ~/uon/${ufile2}/* ${ddir}

```



## mv

```bash

-f：当目标文件存在时，强制覆盖
-i：默认选项，当目标文件存在时，提示是否覆盖
-b：当目标文件存在时，先进行备份在覆盖
-t：先指定目标，在制定源
-v：显示过程
```

------



## sed

### sed命令

```
替换操作：s命令
替换文本中的字符串：

sed 's/book/books/' file
-n选项和p命令一起使用表示只打印那些发生替换的行：

sed -n 's/test/TEST/p' file

直接编辑文件选项-i，会匹配file文件中每一行的第一个book替换为books：

sed -i 's/book/books/g' file
全面替换标记g
使用后缀 /g 标记会替换每一行中的所有匹配：

sed 's/book/books/g' file
```



```
a\ 在当前行下面插入文本。
i\ 在当前行上面插入文本。
c\ 把选定的行改为新的文本。
d 删除，删除选择的行。
D 删除模板块的第一行。
s 替换指定字符
h 拷贝模板块的内容到内存中的缓冲区。
H 追加模板块的内容到内存中的缓冲区。
g 获得内存缓冲区的内容，并替代当前模板块中的文本。
G 获得内存缓冲区的内容，并追加到当前模板块文本的后面。
l 列表不能打印字符的清单。
n 读取下一个输入行，用下一个命令处理新的行而不是用第一个命令。
N 追加下一个输入行到模板块后面并在二者间嵌入一个新行，改变当前行号码。
p 打印模板块的行。
P(大写) 打印模板块的第一行。
q 退出Sed。
b lable 分支到脚本中带有标记的地方，如果分支不存在则分支到脚本的末尾。
r file 从file中读行。
t label if分支，从最后一行开始，条件一旦满足或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。
T label 错误分支，从最后一行开始，一旦发生错误或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。
w file 写并追加模板块到file末尾。 &nbsp;
W file 写并追加模板块的第一行到file末尾。 &nbsp;
! 表示后面的命令对所有没有被选定的行发生作用。 &nbsp;
= 打印当前行号码。 
# 把注释扩展到下一个换行符以前。 &
```

### sed替换标记

```
g 表示行内全面替换。 &nbsp;
p 表示打印行。 &nbsp;
w 表示把行写入一个文件。 &nbsp;
x 表示互换模板块中的文本和缓冲区中的文本。 &nbsp;
y 表示把一个字符翻译为另外的字符（但是不用于正则表达式）
\1 子串匹配标记
& 已匹配字符串标记
```

### sed元字符集

```
^ 匹配行开始，如：/^sed/匹配所有以sed开头的行。
$ 匹配行结束，如：/sed$/匹配所有以sed结尾的行。
. 匹配一个非换行符的任意字符，如：/s.d/匹配s后接一个任意字符，最后是d。
* 匹配0个或多个字符，如：/*sed/匹配所有模板是一个或多个空格后紧跟sed的行。
[] 匹配一个指定范围内的字符，如/[ss]ed/匹配sed和Sed。 &nbsp;
[^] 匹配一个不在指定范围内的字符，如：/[^A-RT-Z]ed/匹配不包含A-R和T-Z的一个字母开头，紧跟ed的行。
\(..\) 匹配子串，保存匹配的字符，如s/\(love\)able/\1rs，loveable被替换成lovers。
& 保存搜索字符用来替换其他字符，如s/love/**&**/，love这成**love**。
\< 匹配单词的开始，如:/\<love/匹配包含以love开头的单词的行。
\> 匹配单词的结束，如/love\>/匹配包含以love结尾的单词的行。
x\{m\} 重复字符x，m次，如：/0\{5\}/匹配包含5个0的行。
x\{m,\} 重复字符x，至少m次，如：/0\{5,\}/匹配至少有5个0的行。
x\{m,n\} 重复字符x，至少m次，不多于n次，如：/0\{5,10\}/匹配5~10个0的行。



```



## grep

### 语法

```
grep [-abcEFGhHilLnqrsvVwxy][-A<显示列数>][-B<显示列数>][-C<显示列数>][-d<进行动作>][-e<范本样式>][-f<范本文件>][--help][范本样式][文件或目录...]
```

### **参数**：

- **-a 或 --text** : 不要忽略二进制的数据。
- **-A<显示行数> 或 --after-context=<显示行数>** : 除了显示符合范本样式的那一列之外，并显示该行之后的内容。
- **-b 或 --byte-offset** : 在显示符合样式的那一行之前，标示出该行第一个字符的编号。
- **-B<显示行数> 或 --before-context=<显示行数>** : 除了显示符合样式的那一行之外，并显示该行之前的内容。
- **-c 或 --count** : 计算符合样式的列数。
- **-C<显示行数> 或 --context=<显示行数>或-<显示行数>** : 除了显示符合样式的那一行之外，并显示该行之前后的内容。
- **-d <动作> 或 --directories=<动作>** : 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。
- **-e<范本样式> 或 --regexp=<范本样式>** : 指定字符串做为查找文件内容的样式。
- **-E 或 --extended-regexp** : 将样式为延伸的正则表达式来使用。
- **-f<规则文件> 或 --file=<规则文件>** : 指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式。
- **-F 或 --fixed-regexp** : 将样式视为固定字符串的列表。
- **-G 或 --basic-regexp** : 将样式视为普通的表示法来使用。
- **-h 或 --no-filename** : 在显示符合样式的那一行之前，不标示该行所属的文件名称。
- **-H 或 --with-filename** : 在显示符合样式的那一行之前，表示该行所属的文件名称。
- **-i 或 --ignore-case** : 忽略字符大小写的差别。
- **-l 或 --file-with-matches** : 列出文件内容符合指定的样式的文件名称。
- **-L 或 --files-without-match** : 列出文件内容不符合指定的样式的文件名称。
- **-n 或 --line-number** : 在显示符合样式的那一行之前，标示出该行的列数编号。
- **-o 或 --only-matching** : 只显示匹配PATTERN 部分。
- **-q 或 --quiet或--silent** : 不显示任何信息。
- **-r 或 --recursive** : 此参数的效果和指定"-d recurse"参数相同。
- **-s 或 --no-messages** : 不显示错误信息。
- **-v 或 --invert-match** : 显示不包含匹配文本的所有行。
- **-V 或 --version** : 显示版本信息。
- **-w 或 --word-regexp** : 只显示全字符合的列。
- **-x --line-regexp** : 只显示全列符合的列。
- **-y** : 此参数的效果和指定"-i"参数相同。



##### **从文件内容查找匹配指定字符串的行：**

```
$ grep "被查找的字符串" 文件名
```

##### 例子：在当前目录里第一级文件夹中寻找包含指定字符串的 .in 文件

```
grep "thermcontact" /.in
```

##### 从文件内容查找与正则表达式匹配的行：

```
$ grep -e "正则表达式" 文件名
```

##### 查找时不区分大小写：

```
$ grep -i "被查找的字符串" 文件名
```

##### 查找匹配的行数：

$ grep -c "被查找的字符串" 文件名

从文件内容查找不匹配指定字符串的行：

```
$ grep -v "被查找的字符串" 文件名
```

##### 从根目录开始查找所有扩展名为 .log 的文本文件，并找出包含 "ERROR" 的行：

```
$ find / -type f -name "*.log" | xargs grep "ERROR"
```

##### 例子：从当前目录开始查找所有扩展名为 .in 的文本文件，并找出包含 "thermcontact" 的行：

```
find . -name "*.in" | xargs grep "thermcontact"
```



------



## 对比：大于、小于、不等于。。。。。

```
大于 -gt (greater than)
小于 -lt (less than)
大于或等于 -ge (greater than or equal)
小于或等于 -le (less than or equal)
-eq	等于
不相等 -ne （not equal）
```



## 执行网络脚本

```bash
bash <(curl -sL https://gitee.com/uon/uon/raw/master/k8s/get-kubeasz.sh)
#bash <(curl -sL )
```

```bash
source <(curl -sL https://gitee.com/uon/uon/raw/master/k8s/get-kubeasz.sh)
```

